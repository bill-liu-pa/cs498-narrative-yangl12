<html>
  <head>
    <link
      href="http://fonts.googleapis.com/css?family=Open+Sans"
      rel="stylesheet"
      type="text/css"
    />
    <link href="style.css" rel="stylesheet" type="text/css" />
    <script src="d3.v3.js" charset="utf-8"></script>
    <script src="https://d3js.org/d3-time.v1.min.js"></script>
    <script src="https://d3js.org/d3-time-format.v2.min.js"></script>
  </head>
  <body>
    <!-- global functions -->
    <script>
      function formatSales(d) {
        var prefix = d3.formatPrefix(d);
        var num = prefix.scale(d).toFixed();
        var re = num + prefix.symbol;
        console.log(re);
        return re;
      }

      function compareNums(a, b) {
        return a - b;
      }
    </script>

    <h1 id="dashTitle">Covid-19 Dashboard - 3</h1>

    <div id="topChart" style="float: left; width: 800px;">
      <h2 style="margin-left: 50px; float: left;">Cases by date</h2>
    </div>

    <div id="bottomChart" style="float: left; width: 800px;">
      <h2>Cases by State</h2>
    </div>

    <script>
      const tParser = d3.timeParse("%Y-%m-%d");

      function buildLine(ds) {
        var margin = { top: 20, right: 30, bottom: 30, left: 40 },
          w = 800 - margin.left - margin.right,
          h = 400 - margin.top - margin.bottom;

        //scales
        var xScale = d3.time
          .scale()
          .domain([tParser("2020-01-21"), tParser("2020-07-25")])
          .range([0, w])
          .nice();

        var yScale = d3.scale
          .linear()
          .domain([0, 4190422])
          .range([h, 0])
          .nice();

        var lineFun = d3.svg

          .line()
          .x(function (d) {
            return xScale(tParser(d.date));
          })
          .y(function (d) {
            return yScale(d.positive);
          })
          .interpolate("linear");

        var svg = d3
          .select("#topChart")
          .append("svg")
          .attr({ width: w, height: h });

        var viz = svg
          .append("g")
          .attr("transform", "translate(40,20)")
          .append("path")
          .attr({
            d: lineFun(ds),
            stroke: "#666666",
            "stroke-width": 2,
            fill: "none",
          });

        // var width = 700,
        //   height = 400,
        //   padding = 100;

        // create an svg container
        //  var vis = svg
        // .append("svg:svg")
        // .attr("width", width)
        // .attr("height", height);

        // define the y scale  (vertical)
        // var yScale = d3.scale
        //   .linear()
        //   .domain([0, 100]) // values between 0 and 100
        //   .range([height - padding, padding]); // map these to the chart height, less padding.
        // //REMEMBER: y axis range has the bigger number first because the y value of zero is at the top of chart and increases as you go down.

        // // define the x scale (horizontal)
        // var mindate = new Date(2020, 1, 21),
        //   maxdate = new Date(2020, 7, 25);

        // var xScale = d3.time
        //   .scale()
        //   .domain([mindate, maxdate]) // values between for month of january
        //   .range([padding, width - padding * 2]); // map these the the chart width = total width minus padding at both sides

        // define the y axis
        var yAxis = d3.svg
          .axis()
          .orient("left")
          .scale(yScale)
          .ticks(10)
          .tickFormat(d3.format(".0s"));

        // define the y axis
        var xAxis = d3.svg.axis().orient("bottom").scale(xScale).ticks(10);

        // draw y axis with labels and move in from the size by the amount of padding
        svg.append("g").attr("transform", "translate(20,0)").call(yAxis);

        // draw x axis with labels and move to the bottom of the chart area
        svg
          .append("g")
          .attr("class", "xaxis") // give it a class so it can be used to select only xaxis labels  below
          .attr("transform", "translate(0,400)")
          .call(xAxis);

        // now rotate text on x axis
        // solution based on idea here: https://groups.google.com/forum/?fromgroups#!topic/d3-js/heOBPQF3sAY
        // first move the text left so no longer centered on the tick
        // then rotate up to get 45 degrees.
        vis
          .selectAll(".xaxis text") // select all the text elements for the xaxis
          .attr("transform", function (d) {
            return (
              "translate(" +
              this.getBBox().h * -2 +
              "," +
              this.getBBox().h +
              ")rotate(-45)"
            );
          });

        // var xAxis = d3.svg.axis().scale(xScale).ticks(20).orient("bottom");

        // var yAxis = d3.svg.axis().scale(yScale).ticks(4).orient("left");

        // svg.append("g").attr("transform", "translate(150,50)").call(yAxis);

        // svg.append("g").attr("transform", "translate(0,360)").call(xAxis);
      }

      //get data and draw things
      d3.csv("us-positive.csv", function (data) {
        buildLine(data);
      });
    </script>

    <!-- build map -->
    <script>
      var margin = { top: 20, right: 30, bottom: 30, left: 40 },
        w = 800 - margin.left - margin.right,
        h = 500 - margin.top - margin.bottom;

      var projection = d3.geo
        .albersUsa()
        .translate([w / 2 + 10, h / 2 - 80])
        .scale([700]);

      var path = d3.geo.path().projection(projection);

      var color = d3.scale
        .linear()
        .range([
          "rgb(254,229,217)",
          "rgb(252,174,145)",
          "rgb(251,106,74)",
          "rgb(203,24,29)",
        ]);

      //Create SVG element
      var svg = d3
        .select("#bottomChart")
        .append("svg")
        .attr("width", w)
        .attr("height", h);

      //Load in Sales Data
      d3.csv("us-states-positive.csv", function (data) {
        //Set input domain for color scale
        color.domain([
          0,
          d3.max(data, function (d) {
            return d.positive;
          }),
        ]);

        //Load in GeoJSON data
        d3.json("us.json", function (json) {
          //Merge the ag. data and GeoJSON
          //Loop through once for each ag. data value
          for (var i = 0; i < data.length; i++) {
            //Grab state name
            var dataState = data[i].state;

            //Grab data value, and convert from string to float
            var dataValue = parseFloat(data[i].positive);

            //Find the corresponding state inside the GeoJSON
            for (var j = 0; j < json.features.length; j++) {
              var jsonState = json.features[j].properties.NAME;

              if (dataState == jsonState) {
                json.features[j].properties.value = dataValue;
                break;
              }
            }
          }

          //add tooltip
          var mapTooltip = d3
            .select("body")
            .append("div")
            .attr("class", "tooltip")
            .attr("id", "mapTooltip")
            .style("opacity", 0);

          //add legend

          //Build Map
          svg
            .selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("d", path)
            .style("fill", function (d) {
              //Get data value
              var value = d.properties.value;

              if (value) {
                //If value exists…
                return color(value);
              } else {
                //If value is undefined…
                return "#fff";
              }
            })
            .on("mouseover", function (d) {
              mapTooltip.transition().duration(500).style("opacity", 0.9);

              var tip = "<strong>" + d.properties.NAME + "</strong><br/>";
              var tip =
                tip +
                "<strong>Cases:</strong>" +
                formatSales(d.properties.value) +
                "<br/>";

              mapTooltip
                .html(tip)
                .style("left", d3.event.pageX + "px")
                .style("top", d3.event.pageY - 28 + "px");
            })
            .on("mouseout", function (d) {
              mapTooltip.transition().duration(500).style("opacity", 0);
            });

          //sort values for color legend

          var legendData = [];

          json.features.forEach(function (prop) {
            var val = parseFloat(prop.properties.value);

            if (val) {
              legendData.push(val);
            }
          });

          legendData.sort(function (a, b) {
            return a - b;
          });

          // add color legend
          svg
            .selectAll("rect")
            .data(legendData)
            .enter()
            .append("rect")
            .attr({
              x: function (d, i) {
                return i * (w / legendData.length);
              },
              y: h - 110,
              width: function (d, i) {
                return w / legendData.length;
              },
              height: 10,
              fill: function (d) {
                return color(d);
              },
            });

          svg
            .selectAll("text")
            .data([legendData[0], legendData[legendData.length - 1]])
            .enter()
            .append("text")
            .text(function (d) {
              return formatSales(d);
            })
            .attr({
              x: function (d, i) {
                if (i == 0) return 0;
                else return (w - margin.left / 2) * i - 10;
              },
              y: h - 120,
              "font-size": "12px",
              "font-family": "sans-serif",
            });
        });
      });
    </script>
  </body>
</html>
